// Please refer to grammar.ebnf for the outline of how the parser works. It is a mandatory read,
// and every change you make here, you must update the grammar with.

//! For using the symbols generated by the lexer and making sense of them in the context of
//! mathematical expressions.

use std::slice::Iter;
use std::iter::Peekable;

use lexer::*;

#[derive(Debug)]
pub enum Expr {
    BinOp(Operator, Box<Expr>, Box<Expr>),
    Pow(Box<Expr>, Box<Expr>),
    Neg(Box<Expr>),
    Function(Function, Box<Expr>),
    Constant(f64),
}

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum ParserError {
    ExpectedClosingParenthesis,
    ExpectedFactor(Option<Token>), // Includes the token it found instead
}
use self::ParserError::*;

/// Turn an array of tokens into an expression, which can be computed into a final number.
pub fn parse(tokens: &[Token]) -> Result<Expr, ParserError> {
    parse_additive_expr(&mut tokens.iter().peekable())
}

/// Additive expressions are things like `expr + expr`, or `expr - expr`. It reads a multiplicative
/// expr first, which allows precedence to exist.
fn parse_additive_expr(tokens: &mut Peekable<Iter<Token>>) -> Result<Expr, ParserError> {
    let mut expr = parse_multiplicative_expr(tokens)?;
    loop {
        match tokens.peek() {
            Some(Token::Operator(op)) if op == &Operator::Plus || op == &Operator::Minus => {
                tokens.next();
                let r_expr = parse_multiplicative_expr(tokens)?;
                expr = Expr::BinOp(*op, Box::new(expr), Box::new(r_expr));
            }
            _ => break,
        }
    }
    Ok(expr)
}

/// Multiplicative expressions are `expr * expr`, or `expr / expr`.
fn parse_multiplicative_expr(tokens: &mut Peekable<Iter<Token>>) -> Result<Expr, ParserError> {
    let mut expr = parse_parenthetical_multiplicative_expr(tokens)?;
    loop {
        match tokens.peek() {
            Some(Token::Operator(op)) if op == &Operator::Star || op == &Operator::Slash => {
                tokens.next();
                let r_expr = parse_parenthetical_multiplicative_expr(tokens)?;
                expr = Expr::BinOp(*op, Box::new(expr), Box::new(r_expr));
            }
            _ => break,
        }
    }
    Ok(expr)
}

/// Parenthetical, multiplicative expressions are just expressions times an expression wrapped in parenthesis: `expr(expr)`, which is
/// the same as `expr * expr`.
fn parse_parenthetical_multiplicative_expr(tokens: &mut Peekable<Iter<Token>>) -> Result<Expr, ParserError> {
    let expr = parse_power_expr(tokens)?;
    match tokens.peek() {
        Some(Token::Operator(op)) if op == &Operator::LParen => {
            tokens.next();
            let internal_expr = parse_additive_expr(tokens)?;
            match tokens.next() {
                Some(Token::Operator(op)) if op == &Operator::RParen => return Ok(Expr::BinOp(Operator::Star, Box::new(expr), Box::new(internal_expr))),
                _ => return Err(ExpectedClosingParenthesis),
            }
        }
        _ => {}
    }
    Ok(expr)
}

/// Power expressions are any expressions with an exponential: `factor ^ factor`.
fn parse_power_expr(tokens: &mut Peekable<Iter<Token>>) -> Result<Expr, ParserError> {
    let mut expr = parse_factor(tokens)?;
    loop {
        match tokens.peek() {
            Some(Token::Operator(op)) if op == &Operator::Caret => {
                tokens.next();
                let exponent = parse_factor(tokens)?;
                expr = Expr::Pow(Box::new(expr), Box::new(exponent));
            }
            _ => break,
        }
    }
    Ok(expr)
}

/// The most important item -- a factor. A factor is generally the bottom level ideas
/// like numbers or expressions in parenthesis. The factor makes the recursion in `Expr`
/// finite.
fn parse_factor(tokens: &mut Peekable<Iter<Token>>) -> Result<Expr, ParserError> {
    match tokens.next() {
        // Parenthetical expressions such as `(expr)`.
        Some(Token::Operator(Operator::LParen)) => {
            let expr = parse_additive_expr(tokens);
            match tokens.next() {
                Some(Token::Operator(Operator::RParen)) => expr,
                _ => Err(ExpectedClosingParenthesis),
            }
        }
        Some(Token::Function(function)) => {
            Ok(Expr::Function(*function, Box::new(parse_factor(tokens)?))) // All functions assume the next factor is its operand.
        }
        Some(Token::Constant(constant)) => {
            Ok(Expr::Constant(match constant {
                Constant::Pi => ::std::f64::consts::PI,
                Constant::E => ::std::f64::consts::E,
            }))
        }
        Some(Token::Operator(Operator::Minus)) => {
            Ok(Expr::Neg(Box::new(parse_factor(tokens)?))) // Unary negative expressions like `-factor`.
        }
        Some(Token::Number(n)) => Ok(Expr::Constant(*n)), // Number constants like `3`, `2.21`, `.34` or `-.2515262`.
        t => Err(ExpectedFactor(t.cloned())), // The token being read isn't in the right place.
    }
}
